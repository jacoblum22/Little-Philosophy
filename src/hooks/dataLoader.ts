/**
 * Data loader — load and parse JSON data files at runtime.
 *
 * Fetches tiles.json, combinations.json, and recipes.json from the
 * build output directory. These files are generated by `npm run build:data`.
 */

import type { Tile } from "../types/tile";
import type { Combination, Recipe } from "../types/combination";

export interface GameData {
  tiles: Tile[];
  combinations: Combination[];
  recipes: Recipe[];
}

/** Map of tile ID → Tile for O(1) lookups. */
export type TileMap = Map<string, Tile>;

const BASE = import.meta.env.BASE_URL;

/** Load all game data from the build output JSON files. */
export async function loadGameData(): Promise<GameData> {
  const [tiles, combinations, recipes] = await Promise.all([
    fetchJson<Tile[]>(`${BASE}data/build/tiles.json`),
    fetchJson<Combination[]>(`${BASE}data/build/combinations.json`),
    fetchJson<Recipe[]>(`${BASE}data/build/recipes.json`),
  ]);
  return { tiles, combinations, recipes };
}

/** Build a tile lookup map from the tiles array. */
export function buildTileMap(tiles: Tile[]): TileMap {
  const map = new Map<string, Tile>();
  for (const tile of tiles) {
    if (map.has(tile.id)) {
      console.warn(`Duplicate tile ID in data: "${tile.id}"`);
    }
    map.set(tile.id, tile);
  }
  return map;
}

async function fetchJson<T>(url: string): Promise<T> {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to load ${url}: ${response.status} ${response.statusText}`);
  }
  try {
    return await response.json() as T;
  } catch (e) {
    throw new Error(`Failed to parse JSON from ${url}: ${e}`);
  }
}
